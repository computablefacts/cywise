<?php

namespace App\Http\Procedures;

use App\Http\Requests\JsonRpcRequest;
use App\Models\Attacker;
use App\Models\Honeypot;
use App\Models\HoneypotEvent;
use Carbon\Carbon;
use Illuminate\Support\Facades\DB;
use Sajya\Server\Attributes\RpcMethod;
use Sajya\Server\Procedure;

class HoneypotsProcedure extends Procedure
{
    public static string $name = 'honeypots';

    #[RpcMethod(
        description: "Get a list of qualified IP addresses to blacklist. If the attacker_id parameter is set, this endpoint only returns the IP addresses of the specified attacker.",
        params: [
            "attacker_id" => "An attacker id (optional).",
        ],
        result: [
            "blacklist" => "The list of IP addresses to blacklist.",
        ]
    )]
    public function blacklist(JsonRpcRequest $request): array
    {
        $params = $request->validate([
            'attacker_id' => 'nullable|integer|exists:am_attackers,id',
        ]);
        /** @var ?int $attackerId */
        $attackerId = $params['attacker_id'] ?? null;
        /** @var array $cywiseIpAddresses */
        $cywiseIpAddresses = config('towerify.adversarymeter.ip_addresses');
        $honeypots = Honeypot::all()->pluck('id');
        $events = HoneypotEvent::select(
            'am_honeypots_events.ip',
            DB::raw('MIN(am_honeypots_events.timestamp) AS first_contact'),
            DB::raw('MAX(am_honeypots_events.timestamp) AS last_contact'),
            DB::raw("MAX(am_honeypots_events.hosting_service_description) AS isp_name"),
            DB::raw("MAX(am_honeypots_events.hosting_service_country_code) AS country_code"),
        )
            ->whereIn('honeypot_id', $honeypots)
            ->whereNotIn('am_honeypots_events.ip', $cywiseIpAddresses)
            ->join('am_attackers', 'am_attackers.id', '=', 'am_honeypots_events.attacker_id');

        if ($attackerId) {
            $events->where('am_honeypots_events.attacker_id', $attackerId);
        }
        return [
            'blacklist' => $events->groupBy('ip')->distinct()->get()->toArray(),
        ];
    }

    #[RpcMethod(
        description: "Returns the number of humans and targeted events for each day of the last 10 days",
        params: [
            "honeypot_id" => "A honeypot identifier.",
        ],
        result: [
            "counts" => "The daily counts.",
        ]
    )]
    public function counts(JsonRpcRequest $request): array
    {
        $params = $request->validate([
            'honeypot_id' => 'required|integer|exists:am_honeypots,id',
        ]);
        /** @var Honeypot $honeypot */
        $honeypot = Honeypot::findOrFail($params['honeypot_id']);
        /** @var array $cywiseIpAddresses */
        $cywiseIpAddresses = config('towerify.adversarymeter.ip_addresses');
        $cutOffTime = Carbon::now()->startOfDay()->subMonth();
        return [
            'counts' => HoneypotEvent::select(
                DB::raw("DATE_FORMAT(timestamp, '%Y-%m-%d') AS date"),
                DB::raw("SUM(CASE WHEN human = 1 OR targeted = 1 THEN 1 ELSE 0 END) AS human_or_targeted"),
                DB::raw("SUM(CASE WHEN human = 0 AND targeted = 0 THEN 1 ELSE 0 END) AS not_human_or_targeted")
            )
                ->where('timestamp', '>=', $cutOffTime)
                ->where('honeypot_id', $honeypot->id)
                ->whereNotIn('am_honeypots_events.ip', $cywiseIpAddresses)
                ->groupBy('date')
                ->orderBy('date', 'desc') // keep only the most recent ones
                ->limit(10)
                ->get()
                ->sortBy('date') // most recent date at the end
                ->toArray(),
        ];
    }

    #[RpcMethod(
        description: "The last events generated by the honeypots. If the honeypot_id parameter is set, this endpoint only returns the events of the specified honeypot.",
        params: [
            "honeypot_id" => "A honeypot identifier (optional).",
            "limit" => "The number of events to return (optional).",
            "human" => "Only keep events that have been generated by manually tinkering with the honeypots (optional).",
            "targeted" => "Only keep events that have been generated by a lateral movement (optional).",
        ],
        result: [
            "events" => "A list of events.",
        ]
    )]
    public function events(JsonRpcRequest $request): array
    {
        $params = $request->validate([
            'honeypot_id' => 'nullable|integer|exists:am_honeypots,id',
            'limit' => 'nullable|integer|min:1|max:5000',
            'human' => 'nullable|boolean',
            'targeted' => 'nullable|boolean',
        ]);
        /** @var array $honeypots */
        $honeypots = isset($params['honeypot_id']) ? [$params['honeypot_id']] : Honeypot::all()->pluck('id');
        /** @var int $limit */
        $limit = $params['limit'] ?? 1000;
        /** @var boolean $human */
        $human = $params['human'] ?? false;
        /** @var boolean $targeted */
        $targeted = $params['targeted'] ?? false;
        /** @var array $cywiseIpAddresses */
        $cywiseIpAddresses = config('towerify.adversarymeter.ip_addresses');
        $events = HoneypotEvent::select(
            'am_honeypots_events.*',
            DB::raw("CASE WHEN am_attackers.name IS NULL THEN '-' ELSE am_attackers.name END AS internal_name"),
            DB::raw("CASE WHEN am_attackers.id IS NULL THEN '-' ELSE am_attackers.id END AS attacker_id"),
        )
            ->whereIn('honeypot_id', $honeypots)
            ->whereNotIn('ip', $cywiseIpAddresses)
            ->leftJoin('am_attackers', 'am_attackers.id', '=', 'am_honeypots_events.attacker_id');

        if ($human) {
            $events->where('human', true);
        }
        if ($targeted) {
            $events->where('targeted', true);
        }
        return [
            'events' => $events->orderBy('timestamp', 'desc')
                ->limit($limit)
                ->get()
                ->map(function (HoneypotEvent $event) {
                    return [
                        'timestamp' => $event->timestamp->utc()->format('Y-m-d H:i:s') . ' UTC',
                        'event_type' => $event->event,
                        'event_details' => $event->details,
                        'attacker_ip' => $event->ip,
                        'attacker_name' => $event->internal_name,
                        'attacker_id' => $event->attacker_id,
                    ];
                })
                ->toArray(),
        ];
    }

    #[RpcMethod(
        description: "Returns the list of human attackers that targeted your honeypots.",
        params: [],
        result: [
            "attackers" => "The list of human attackers that targeted your honeypots.",
        ]
    )]
    public function attackers(JsonRpcRequest $request): array
    {
        $honeypots = Honeypot::all()->pluck('id');
        $totalNumberOfEvents = HoneypotEvent::whereIn('honeypot_id', $honeypots)->count();
        return [
            'attackers' => Attacker::select('am_attackers.*')
                ->join('am_honeypots_events', 'am_honeypots_events.attacker_id', '=', 'am_attackers.id')
                ->whereIn('am_honeypots_events.honeypot_id', $honeypots)
                ->orderBy('am_attackers.name')
                ->orderBy('am_attackers.last_contact')
                ->distinct()
                ->get()
                ->map(function (Attacker $attacker) use ($totalNumberOfEvents) {
                    return [
                        'id' => $attacker->id,
                        'name' => $attacker->name,
                        'first_contact' => $attacker->first_contact->utc()->format('Y-m-d H:i') . ' UTC',
                        'last_contact' => $attacker->last_contact->utc()->format('Y-m-d H:i') . ' UTC',
                        'aggressiveness' => $attacker->aggressiveness($totalNumberOfEvents),
                        'ip_addresses' => $attacker->knownIpAddresses(),
                    ];
                })
                ->toArray(),
        ];
    }

    #[RpcMethod(
        description: "Get the full profile of an attacker.",
        params: [
            "attacker_id" => "An attacker id."
        ],
        result: [
            "profile" => "The attacker profile: internal name, date of first contact, date of last contact, etc.",
            "ip_addresses" => "The attacker's known IP addresses.",
            "events" => "The last known events triggered by the attacker.",
            "tools" => "The attacker toolkit.",
            "counts" => "Misc. counts (nb human events, nb targeted events, etc.)",
            "skills" => "The attacker's skills.",
        ]
    )]
    public function attackerProfile(JsonRpcRequest $request): array
    {
        $params = $request->validate([
            'attacker_id' => 'required|integer|exists:am_attackers,id',
        ]);
        /** @var Attacker $attacker */
        $attacker = Attacker::findOrFail($params['attacker_id']);
        $honeypots = Honeypot::all()->pluck('id');
        $totalNumberOfEvents = HoneypotEvent::whereIn('honeypot_id', $honeypots)->count();
        $nbTools = $attacker->usedTools()->count();
        $nbCves = $attacker->testedCves()->count();
        $nbIpAddresses = $attacker->knownIpAddresses()->count();
        $nbEvents = $attacker->events()->count();
        $nbHumans = $attacker->humans()->count();
        $nbTargeted = $attacker->targeted()->count();
        $nbCuratedWordlist = $attacker->curatedWordlist()->count();
        $nbCuratedPasswords = $attacker->curatedPasswords()->count();
        return [
            'profile' => [
                'id' => $attacker->id,
                'name' => $attacker->name,
                'first_contact' => $attacker->first_contact->utc()->format('Y-m-d H:i:s') . ' UTC',
                'last_contact' => $attacker->last_contact->utc()->format('Y-m-d H:i:s') . ' UTC',
                'count' => $attacker->events()->count(),
                'aggressiveness' => $attacker->aggressiveness($totalNumberOfEvents),
            ],
            'ip_addresses' => $attacker->knownIpAddresses(),
            'events' => $attacker->events()
                ->orderBy('timestamp', 'desc')
                ->limit(500)
                ->get()
                ->map(function (HoneypotEvent $event) {
                    return [
                        'timestamp' => $event->timestamp->utc()->format('Y-m-d H:i:s') . ' UTC',
                        'event_type' => $event->event,
                        'event_details' => $event->details,
                        'attacker_ip' => $event->ip,
                    ];
                })
                ->toArray(),
            'tools' => $attacker->usedTools()->toArray(),
            'counts' => [
                'total_number_of_events' => $nbEvents,
                'total_number_of_human_events' => $nbHumans,
                'total_number_of_targeted_events' => $nbTargeted,
                'total_number_of_cve_events' => $nbCves,
            ],
            'skills' => [
                'toolbox' => min($nbTools * 1, 10),
                'cve_collection' => min($nbCves / 1000 * 100, 10),
                'manual_testing' => min($nbHumans / 50 * 100, 10),
                'stealth_techniques' => min($nbIpAddresses / 5 * 10, 10),
                'curated_wordlist' => $nbCuratedPasswords ? 10 : min($nbCuratedWordlist / 50 * 100, 10),
                'persistence' => min($attacker->first_contact->diffInDays($attacker->last_contact) / 10 * 10, 10),
            ],
        ];
    }
}
